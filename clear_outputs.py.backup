#!/usr/bin/env python3
"""
A script to clear output files from specified directories within the F.A.D.E project.
This includes AlphaFold structures, docking results, and generated molecules.
"""

import os
import shutil
import argparse
import time
from datetime import datetime, timedelta
from typing import List, Tuple

def get_directory_size(path: str) -> int:
    """
    Calculate the total size of a directory in bytes.
    
    Args:
        path: Directory path
        
    Returns:
        Total size in bytes
    """
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            if os.path.exists(filepath):
                total_size += os.path.getsize(filepath)
    return total_size

def format_size(size_bytes: int) -> str:
    """
    Format size in bytes to human-readable string.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Formatted string (e.g., "1.5 GB")
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} PB"

def clear_outputs(days: int = 0, dry_run: bool = False, keep_best: bool = False) -> Tuple[int, int, int]:
    """
    Deletes output files from predefined directories.

    Args:
        days: If greater than 0, only deletes files older than this number of days.
              If 0, deletes all files.
        dry_run: If True, only shows what would be deleted without actually deleting.
        keep_best: If True, keeps files with 'best' in the name (best models).

    Returns:
        Tuple of (deleted_count, skipped_count, total_size_freed)
    """
    output_dirs = [
        "agents/data/outputs",
        "data/outputs",
        "results",
        "test_results",
        "current_test",
        "summary_test",
    ]

    now = time.time()
    deleted_count = 0
    skipped_count = 0
    total_size_freed = 0
    files_to_keep = []

    if days > 0:
        print(f"{'[DRY RUN] ' if dry_run else ''}Deleting output files older than {days} days...")
        time_threshold = now - timedelta(days=days).total_seconds()
    else:
        print(f"{'[DRY RUN] ' if dry_run else ''}Deleting all output files...")
        time_threshold = float('inf')  # Delete all files regardless of age

    # Patterns to preserve if keep_best is True
    preserve_patterns = ['best', 'final', 'top_'] if keep_best else []

    for output_dir in output_dirs:
        if not os.path.exists(output_dir):
            print(f"Directory not found, skipping: {output_dir}")
            continue

        print(f"\nChecking directory: {output_dir}")
        
        # Calculate directory size before deletion
        dir_size_before = get_directory_size(output_dir)
        
        for root, dirs, files in os.walk(output_dir):
            # Skip .git directories
            if '.git' in root:
                continue
                
            # Skip logs directories (handled by clear_logs.py)
            if 'logs' in os.path.basename(root):
                continue
            
            # Process files
            for filename in files:
                file_path = os.path.join(root, filename)
                
                # Skip .gitkeep files
                if filename == '.gitkeep':
                    continue
                
                # Check if file should be preserved
                should_preserve = False
                if keep_best:
                    for pattern in preserve_patterns:
                        if pattern in filename.lower():
                            should_preserve = True
                            files_to_keep.append(file_path)
                            break
                
                if should_preserve:
                    skipped_count += 1
                    continue
                
                # Check file age
                try:
                    file_mod_time = os.path.getmtime(file_path)
                    file_size = os.path.getsize(file_path)
                    
                    if days == 0 or file_mod_time < time_threshold:
                        if dry_run:
                            print(f"  [Would delete] {file_path} ({format_size(file_size)})")
                            deleted_count += 1
                            total_size_freed += file_size
                        else:
                            try:
                                os.remove(file_path)
                                print(f"  Deleted: {file_path} ({format_size(file_size)})")
                                deleted_count += 1
                                total_size_freed += file_size
                            except OSError as e:
                                print(f"  Error deleting {file_path}: {e}")
                except OSError as e:
                    print(f"  Error accessing {file_path}: {e}")
            
            # Process directories (remove empty ones)
            if not dry_run:
                for dirname in dirs:
                    dir_path = os.path.join(root, dirname)
                    try:
                        # Try to remove directory if it's empty
                        if not os.listdir(dir_path):
                            os.rmdir(dir_path)
                            print(f"  Removed empty directory: {dir_path}")
                    except OSError:
                        # Directory not empty or other error, skip
                        pass

    # Special handling for large AlphaFold output directories
    alphafold_dirs = [
        "agents/data/outputs/structures",
        "data/outputs/structures"
    ]
    
    for af_dir in alphafold_dirs:
        if not os.path.exists(af_dir):
            continue
            
        print(f"\nChecking AlphaFold outputs: {af_dir}")
        
        for protein_dir in os.listdir(af_dir):
            protein_path = os.path.join(af_dir, protein_dir)
            if not os.path.isdir(protein_path):
                continue
            
            # Check for AlphaFold3 output subdirectories
            for item in os.listdir(protein_path):
                item_path = os.path.join(protein_path, item)
                
                # Skip best model files if keep_best is True
                if keep_best and 'best' in item.lower():
                    print(f"  Keeping best model: {item_path}")
                    skipped_count += 1
                    continue
                
                if os.path.isdir(item_path) and 'af3_input' in item:
                    # This is an AlphaFold output directory
                    dir_size = get_directory_size(item_path)
                    dir_mod_time = os.path.getmtime(item_path)
                    
                    if days == 0 or dir_mod_time < time_threshold:
                        if dry_run:
                            print(f"  [Would delete] AlphaFold output: {item_path} ({format_size(dir_size)})")
                            deleted_count += 1
                            total_size_freed += dir_size
                        else:
                            try:
                                shutil.rmtree(item_path)
                                print(f"  Deleted AlphaFold output: {item_path} ({format_size(dir_size)})")
                                deleted_count += 1
                                total_size_freed += dir_size
                            except OSError as e:
                                print(f"  Error deleting {item_path}: {e}")

    print(f"\n{'[DRY RUN] ' if dry_run else ''}Output cleanup complete.")
    print(f"Files deleted: {deleted_count}")
    print(f"Files skipped: {skipped_count}")
    print(f"Space freed: {format_size(total_size_freed)}")
    
    if keep_best and files_to_keep:
        print(f"\nPreserved {len(files_to_keep)} best/final files")
    
    return deleted_count, skipped_count, total_size_freed

def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Clear output files from F.A.D.E project directories.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "--days",
        type=int,
        default=0,
        help="""Delete outputs older than this many days.
If 0 or not specified, all outputs will be deleted."""
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be deleted without actually deleting anything."
    )
    parser.add_argument(
        "--keep-best",
        action="store_true",
        help="Keep files with 'best' or 'final' in the name (e.g., best models)."
    )
    parser.add_argument(
        "--confirm",
        action="store_true",
        help="Skip confirmation prompt (use with caution!)."
    )
    
    args = parser.parse_args()
    
    # Show warning and get confirmation unless --confirm is used
    if not args.confirm and not args.dry_run:
        print("⚠️  WARNING: This will delete output files from the F.A.D.E project!")
        print("This includes:")
        print("  - AlphaFold structure predictions")
        print("  - Docking results")
        print("  - Generated molecules")
        print("  - Test results")
        print("")
        if args.keep_best:
            print("Note: Files with 'best' or 'final' in the name will be preserved.")
        print("")
        
        response = input("Are you sure you want to continue? (yes/no): ").strip().lower()
        if response not in ['yes', 'y']:
            print("Operation cancelled.")
            return
    
    # Run the cleanup
    clear_outputs(args.days, args.dry_run, args.keep_best)

if __name__ == "__main__":
    main()
